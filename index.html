import React, { useState, useEffect, useRef, useCallback } from 'react';
import { RefreshCw, Play, Trophy } from 'lucide-react';

const TurkeyCannon = () => {
  // Game States: 'menu', 'aiming', 'powering', 'flying', 'landed'
  const [gameState, setGameState] = useState('menu');
  const [score, setScore] = useState(0); // Distance
  const [highScore, setHighScore] = useState(0);
  
  // Physics State
  const [turkeyPos, setTurkeyPos] = useState({ x: 0, y: 0, rotation: 0 });
  const [cameraX, setCameraX] = useState(0);
  
  // Launch State
  const [angle, setAngle] = useState(45);
  const [power, setPower] = useState(0);
  const [angleDirection, setAngleDirection] = useState(1);
  const [powerDirection, setPowerDirection] = useState(1);

  // Game Objects
  const [objects, setObjects] = useState([]);
  const [specialEnd, setSpecialEnd] = useState(false); // True if hit table
  
  // Refs for physics loop (to avoid closure staleness)
  const physicsRef = useRef({
    x: 0, y: 0, vx: 0, vy: 0, rot: 0, rotSpeed: 0, isFlying: false
  });
  const requestRef = useRef();
  
  // Constants
  const GROUND_Y = 500; // The "floor" in SVG coordinates
  const GRAVITY = 0.4;
  const AIR_DRAG = 0.995;
  const GROUND_FRICTION = 0.8;
  const BOUNCE_DAMPING = 0.6;
  
  // Generate obstacles
  const generateObjects = () => {
    const objs = [];
    let currentX = 800; // Start placing objects after the cannon
    
    // Generate for 20,000 pixels of distance
    while (currentX < 50000) {
      currentX += 400 + Math.random() * 800;
      
      const rand = Math.random();
      let type = 'hay'; // Standard bounce
      
      if (rand > 0.92) type = 'table'; // 8% chance of death
      else if (rand > 0.75) type = 'tnt'; // 17% chance of boost
      else type = 'hay'; // 75% chance of bounce
      
      objs.push({ x: currentX, type, id: currentX });
    }
    return objs;
  };

  const startGame = () => {
    setGameState('aiming');
    setScore(0);
    setSpecialEnd(false);
    setObjects(generateObjects());
    physicsRef.current = { x: 100, y: GROUND_Y - 50, vx: 0, vy: 0, rot: 0, rotSpeed: 0, isFlying: false };
    setTurkeyPos({ x: 100, y: GROUND_Y - 50, rotation: 0 });
    setCameraX(0);
    setAngle(45);
    setPower(0);
  };

  const handleInput = () => {
    if (gameState === 'aiming') {
      setGameState('powering');
    } else if (gameState === 'powering') {
      launchTurkey();
    } else if (gameState === 'landed') {
      startGame();
    }
  };

  const launchTurkey = () => {
    setGameState('flying');
    const rad = (angle * Math.PI) / 180;
    const velocity = 15 + (power / 100) * 25; // Speed between 15 and 40
    
    physicsRef.current = {
      x: 100, // Cannon muzzle x
      y: GROUND_Y - 80, // Cannon muzzle y
      vx: Math.cos(rad) * velocity,
      vy: -Math.sin(rad) * velocity,
      rot: -45,
      rotSpeed: 10,
      isFlying: true
    };
  };

  // Input Loops (Angle & Power)
  useEffect(() => {
    let interval;
    if (gameState === 'aiming') {
      interval = setInterval(() => {
        setAngle(prev => {
          if (prev >= 80) setAngleDirection(-1);
          if (prev <= 10) setAngleDirection(1);
          return prev + angleDirection;
        });
      }, 20);
    } else if (gameState === 'powering') {
      interval = setInterval(() => {
        setPower(prev => {
          if (prev >= 100) setPowerDirection(-1);
          if (prev <= 0) setPowerDirection(1);
          return prev + powerDirection * 2;
        });
      }, 10);
    }
    return () => clearInterval(interval);
  }, [gameState, angleDirection, powerDirection]);

  // Physics Loop
  const updatePhysics = useCallback(() => {
    if (gameState !== 'flying') return;

    const p = physicsRef.current;
    
    // Apply Forces
    p.vy += GRAVITY;
    p.vx *= AIR_DRAG;
    p.vy *= AIR_DRAG;
    
    // Move
    p.x += p.vx;
    p.y += p.vy;
    p.rot += p.rotSpeed;

    // Ground Collision
    if (p.y >= GROUND_Y) {
      p.y = GROUND_Y;
      
      // Bounce or Slide?
      if (Math.abs(p.vy) > 2) {
        p.vy = -p.vy * BOUNCE_DAMPING;
        p.vx *= GROUND_FRICTION; // Friction on bounce impact
        p.rotSpeed *= 0.8;
      } else {
        p.vy = 0;
        p.vx *= GROUND_FRICTION; // Slide friction
        p.rotSpeed *= 0.8; // Stop rotating as we slide
        p.rot = 0; // Align to ground
      }

      // Stop Condition
      if (Math.abs(p.vx) < 0.1 && Math.abs(p.vy) < 0.1) {
        p.isFlying = false;
        setGameState('landed');
        if (p.x > highScore) setHighScore(Math.floor(p.x));
      }
    }

    // Object Collision
    // Simple box collision
    const turkeyRadius = 20;
    objects.forEach(obj => {
      // Check X range (object width approx 60)
      if (p.x + turkeyRadius > obj.x && p.x - turkeyRadius < obj.x + 60) {
        // Check Y range (objects sit on ground)
        if (p.y + turkeyRadius > GROUND_Y - 50) { // Approx object height
          
          if (obj.type === 'tnt') {
             // EXPLOSION
             p.vy = -25; // Big bounce up
             p.vx += 15; // Big boost forward
             p.rotSpeed = 20;
             p.y = GROUND_Y - 60; // Prevent sticking
          } else if (obj.type === 'hay') {
             // BOUNCE
             p.vy = -15;
             p.vx *= 1.1; // Slight speed maintenance
             p.y = GROUND_Y - 60;
          } else if (obj.type === 'table') {
             // GAME OVER
             p.vx = 0;
             p.vy = 0;
             p.y = GROUND_Y - 30; // Sit on table
             p.isFlying = false;
             setSpecialEnd(true);
             setGameState('landed');
             if (p.x > highScore) setHighScore(Math.floor(p.x));
          }
        }
      }
    });

    // Update State for React Render
    setTurkeyPos({ x: p.x, y: p.y, rotation: p.rot });
    setScore(Math.floor(p.x / 10)); // 10px = 1m
    
    // Camera Follow logic (keep turkey left-center)
    const targetCamX = p.x - 200; // Keep turkey 200px from left
    setCameraX(prev => Math.max(0, targetCamX)); // Don't scroll left of 0

    if (p.isFlying) {
      requestRef.current = requestAnimationFrame(updatePhysics);
    }
  }, [gameState, objects, highScore]);

  useEffect(() => {
    if (gameState === 'flying') {
      requestRef.current = requestAnimationFrame(updatePhysics);
    }
    return () => cancelAnimationFrame(requestRef.current);
  }, [gameState, updatePhysics]);


  return (
    <div 
      className="fixed inset-0 overflow-hidden bg-sky-200 font-sans select-none touch-manipulation cursor-pointer"
      onMouseDown={handleInput}
      onTouchStart={handleInput}
    >
      
      {/* --- UI LAYER --- */}
      <div className="absolute top-4 left-4 z-50 flex gap-4 pointer-events-none">
        <div className="bg-white/90 p-3 rounded-xl shadow-lg border-2 border-orange-200">
          <div className="text-xs text-orange-600 font-bold uppercase">Distance</div>
          <div className="text-2xl font-black text-orange-800">{score}m</div>
        </div>
        {highScore > 0 && (
          <div className="bg-white/50 p-3 rounded-xl shadow-lg border-2 border-orange-100">
             <div className="text-xs text-orange-600 font-bold uppercase">Best</div>
             <div className="text-xl font-bold text-orange-800 flex items-center gap-1">
                <Trophy size={16} /> {Math.floor(highScore / 10)}m
             </div>
          </div>
        )}
      </div>

      {/* --- MENU OVERLAYS --- */}
      {gameState === 'menu' && (
        <div className="absolute inset-0 z-50 flex items-center justify-center bg-black/40 backdrop-blur-sm">
          <div className="bg-white p-8 rounded-3xl shadow-2xl max-w-sm text-center animate-in zoom-in duration-300 border-4 border-orange-500">
            <h1 className="text-4xl font-black text-orange-800 mb-2">Turkey Cannon</h1>
            <p className="text-stone-600 mb-6">Launch the bird! Avoid the dinner table.</p>
            <div className="flex justify-center mb-6 text-4xl">ðŸ¦ƒðŸ’¨</div>
            <button className="bg-orange-500 hover:bg-orange-600 text-white font-bold py-3 px-8 rounded-full text-xl shadow-lg w-full flex items-center justify-center gap-2">
              <Play fill="currentColor" /> Play
            </button>
            <p className="text-xs text-stone-400 mt-4">Tap to set Angle, then Power</p>
          </div>
        </div>
      )}

      {gameState === 'landed' && (
        <div className="absolute inset-0 z-50 flex items-center justify-center bg-black/40 backdrop-blur-sm">
          <div className="bg-white p-8 rounded-3xl shadow-2xl max-w-sm text-center animate-in slide-in-from-bottom-10 border-4 border-orange-500">
            <h2 className="text-3xl font-bold text-stone-800 mb-2">
              {specialEnd ? "DINNER TIME!" : "Flight Over"}
            </h2>
            <div className="text-xs text-stone-500 uppercase tracking-widest font-bold">Total Distance</div>
            <div className="text-6xl font-black text-orange-600 mb-6">{score}m</div>
            
            {specialEnd ? (
               <div className="bg-red-100 text-red-800 p-4 rounded-xl mb-6 text-sm font-bold">
                  You hit the dinner table. Game Over.
               </div>
            ) : null}

            <button className="bg-orange-500 hover:bg-orange-600 text-white font-bold py-3 px-8 rounded-full text-xl shadow-lg w-full flex items-center justify-center gap-2">
              <RefreshCw /> Launch Again
            </button>
          </div>
        </div>
      )}


      {/* --- GAME WORLD --- */}
      {/* We translate the entire world group based on cameraX */}
      <svg 
        className="w-full h-full"
        viewBox={`0 0 ${window.innerWidth} ${window.innerHeight}`}
        preserveAspectRatio="xMidYMid slice"
      >
        <g transform={`translate(${-cameraX}, 0)`}>
          
          {/* Background Elements (Parallax) */}
          {/* Sky Gradient handled by CSS class on div */}
          
          {/* Far Hills */}
          <path 
             d={`M ${cameraX} 500 Q ${cameraX + 500} 300 ${cameraX + 1000} 500 T ${cameraX + 2000} 500 V 1000 H ${cameraX} Z`} 
             fill="#84cc16" 
             className="opacity-50"
          />
           <path 
             d={`M ${cameraX - 200} 550 Q ${cameraX + 600} 400 ${cameraX + 1400} 550 V 1000 H ${cameraX - 200} Z`} 
             fill="#65a30d" 
             className="opacity-70"
          />

          {/* Clouds (Move with camera but slower) */}
          <g transform={`translate(${cameraX * 0.8}, 0)`}>
             <Cloud x={200} y={100} scale={1} />
             <Cloud x={800} y={150} scale={1.5} />
             <Cloud x={1400} y={80} scale={0.8} />
          </g>

          {/* Cannon (Fixed at start) */}
          <g transform="translate(100, 500)">
            {/* Base */}
            <path d="M-30 0 L30 0 L20 -40 L-20 -40 Z" fill="#44403c" />
            <circle cx="0" cy="0" r="25" fill="#292524" />
            
            {/* Barrel (Rotates) */}
            <g transform={`rotate(${-angle})`}>
              <rect x="-15" y="-80" width="30" height="80" fill="#1c1917" rx="5" />
              <rect x="-18" y="-20" width="36" height="10" fill="#44403c" />
              {/* Power Meter on Cannon */}
              {(gameState === 'aiming' || gameState === 'powering') && (
                <rect x="20" y={-80 + (80 - (power/100)*80)} width="10" height={(power/100)*80} fill={power > 90 ? '#ef4444' : '#eab308'} />
              )}
            </g>
          </g>

          {/* Obstacles */}
          {objects.map((obj) => (
             <g key={obj.id} transform={`translate(${obj.x}, ${GROUND_Y})`}>
               {obj.type === 'hay' && <HayBale />}
               {obj.type === 'tnt' && <TNTBox />}
               {obj.type === 'table' && <DinnerTable />}
             </g>
          ))}

          {/* The Turkey */}
          <g 
             transform={`translate(${turkeyPos.x}, ${turkeyPos.y}) rotate(${turkeyPos.rotation})`}
          >
             {specialEnd ? <RoastedTurkey /> : <FlyingTurkey />}
          </g>

          {/* Ground */}
          <rect x={cameraX - 100} y={GROUND_Y} width={window.innerWidth + 200} height={500} fill="#4d7c0f" />
          {/* Ground pattern/grass details could go here */}

          {/* Distance Markers */}
          {Array.from({ length: 50 }).map((_, i) => (
             <g key={i} transform={`translate(${(i+1) * 1000}, ${GROUND_Y + 30})`}>
                <text textAnchor="middle" fill="white" fontSize="14" fontWeight="bold">{(i+1)*100}m</text>
                <line x1="0" y1="-30" x2="0" y2="-10" stroke="white" strokeWidth="2" strokeOpacity="0.5"/>
             </g>
          ))}

        </g>
      </svg>
    </div>
  );
};

// --- ASSET COMPONENTS ---

const FlyingTurkey = () => (
  <g transform="translate(-20, -20) scale(0.6)">
    {/* Body */}
    <ellipse cx="30" cy="40" rx="25" ry="18" fill="#78350f" />
    {/* Wings flapping logic could go here, stick to static flight pose */}
    <path d="M20 35 Q 5 20 25 20" stroke="#451a03" strokeWidth="3" fill="none" />
    <path d="M40 35 Q 55 20 35 20" stroke="#451a03" strokeWidth="3" fill="none" />
    {/* Neck/Head */}
    <circle cx="55" cy="25" r="12" fill="#78350f" />
    <path d="M63 22 L 73 25 L 63 28 Z" fill="#facc15" /> {/* Beak */}
    <path d="M62 28 Q 65 35 60 38" stroke="#dc2626" strokeWidth="3" /> {/* Snood */}
    <circle cx="58" cy="22" r="3" fill="white" />
    <circle cx="59" cy="22" r="1" fill="black" />
    {/* Tail */}
    <path d="M5 40 L -10 30 L 5 50" fill="#ea580c" />
  </g>
);

const RoastedTurkey = () => (
  <g transform="translate(-25, -15) scale(0.7)">
    <ellipse cx="35" cy="40" rx="30" ry="20" fill="#a16207" />
    <circle cx="15" cy="40" r="8" fill="#a16207" />
    <circle cx="55" cy="40" r="8" fill="#a16207" />
    <path d="M10 40 L 0 40" stroke="white" strokeWidth="4" />
    <path d="M60 40 L 70 40" stroke="white" strokeWidth="4" />
    {/* Steam lines */}
    <path d="M35 15 Q 40 5 35 0" stroke="white" strokeWidth="2" strokeOpacity="0.5" />
    <path d="M45 15 Q 50 5 45 0" stroke="white" strokeWidth="2" strokeOpacity="0.5" />
  </g>
);

const HayBale = () => (
  <g transform="translate(0, -40)">
     <rect x="0" y="0" width="50" height="40" fill="#eab308" rx="2" />
     <line x1="10" y1="0" x2="10" y2="40" stroke="#ca8a04" strokeWidth="2" />
     <line x1="25" y1="0" x2="25" y2="40" stroke="#ca8a04" strokeWidth="2" />
     <line x1="40" y1="0" x2="40" y2="40" stroke="#ca8a04" strokeWidth="2" />
     <line x1="0" y1="10" x2="50" y2="10" stroke="#ca8a04" strokeWidth="2" />
     <line x1="0" y1="30" x2="50" y2="30" stroke="#ca8a04" strokeWidth="2" />
  </g>
);

const TNTBox = () => (
  <g transform="translate(0, -40)">
    <rect x="0" y="0" width="40" height="40" fill="#dc2626" rx="2" />
    <text x="20" y="25" textAnchor="middle" fill="white" fontWeight="bold" fontSize="14">TNT</text>
    {/* Fuse */}
    <path d="M20 0 Q 20 -10 30 -15" stroke="#44403c" strokeWidth="2" fill="none" />
    <circle cx="30" cy="-15" r="2" fill="#f59e0b" className="animate-pulse" />
  </g>
);

const DinnerTable = () => (
  <g transform="translate(0, -40)">
    {/* Tablecloth */}
    <rect x="0" y="0" width="80" height="10" fill="white" />
    {/* Legs */}
    <rect x="10" y="10" width="5" height="30" fill="#78350f" />
    <rect x="65" y="10" width="5" height="30" fill="#78350f" />
    {/* Plates */}
    <ellipse cx="20" cy="0" rx="8" ry="2" fill="#e5e5e5" />
    <ellipse cx="60" cy="0" rx="8" ry="2" fill="#e5e5e5" />
    <rect x="0" y="0" width="80" height="40" fill="transparent" /> {/* Hitbox visual help */}
  </g>
);

const Cloud = ({ x, y, scale }) => (
  <path 
    transform={`translate(${x}, ${y}) scale(${scale})`}
    d="M25,60.5 c0,0-23.5-12.5-3.5-50.5 c0,0,13-33.5,45.5-10.5 c0,0,17.5-31.5,47.5-0.5 c0,0,32.5-11.5,30.5,29.5 c0,0,22,5.5,6,32.5 Z" 
    fill="white" 
    opacity="0.8" 
  />
);

export default TurkeyCannon;
