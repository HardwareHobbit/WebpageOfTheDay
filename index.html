<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Happy Thanksgiving: Turkey Toss!</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(to bottom, #87CEEB, #E0F6FF);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none; /* Prevent scrolling on mobile */
        }
        #gameCanvas {
            display: block;
        }
        .ui-layer {
            position: absolute;
            pointer-events: none;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }
        .interactive {
            pointer-events: auto;
        }
        /* Custom animations */
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        .pulse-anim {
            animation: pulse 2s infinite;
        }
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>

    <!-- Canvas Layer -->
    <canvas id="gameCanvas"></canvas>

    <!-- UI Overlay Layer -->
    <div class="ui-layer">
        
        <!-- Header / Score -->
        <div class="flex justify-between items-start">
            <div class="bg-white/80 backdrop-blur-md p-4 rounded-xl shadow-lg border-2 border-orange-300">
                <h1 class="text-2xl font-bold text-orange-800 m-0 leading-none">ü¶É Turkey Toss</h1>
                <p class="text-sm text-gray-600 mt-1">Distance: <span id="scoreDisplay" class="font-mono font-bold text-lg text-orange-600">0</span> ft</p>
                <p class="text-xs text-gray-500">Best: <span id="highScoreDisplay" class="font-mono">0</span> ft</p>
            </div>
            
            <div id="tutorial" class="bg-black/60 text-white p-3 rounded-lg text-sm max-w-[200px] text-right">
                Aim with mouse/touch.<br>
                <strong>Hold & Release</strong> to Fire!
            </div>
        </div>

        <!-- Game Over Modal -->
        <div id="gameOverScreen" class="absolute inset-0 flex items-center justify-center bg-black/50 backdrop-blur-sm hidden interactive z-50">
            <div class="bg-white p-8 rounded-2xl shadow-2xl text-center max-w-md w-full border-4 border-orange-500 transform scale-100 transition-transform">
                <div class="text-6xl mb-4">üçó</div>
                <h2 class="text-4xl font-black text-orange-800 mb-2">DINNER IS SERVED!</h2>
                <p class="text-gray-600 mb-6 text-lg">You traveled <span id="finalScore" class="font-bold text-orange-600">0</span> feet.</p>
                
                <div class="bg-orange-100 p-4 rounded-lg mb-6 text-left">
                    <p class="font-serif italic text-orange-900">"Wishing you a Thanksgiving overflowing with love, laughter, and bouncing turkeys."</p>
                </div>

                <button onclick="resetGame()" class="w-full bg-gradient-to-r from-orange-500 to-red-600 hover:from-orange-600 hover:to-red-700 text-white font-bold py-4 px-6 rounded-xl text-xl shadow-lg transform transition active:scale-95">
                    Launch Again! üöÄ
                </button>
            </div>
        </div>

    </div>

<script>
/**
 * GAME CONFIGURATION & STATE
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreDisplay = document.getElementById('scoreDisplay');
const highScoreDisplay = document.getElementById('highScoreDisplay');
const gameOverScreen = document.getElementById('gameOverScreen');
const finalScoreSpan = document.getElementById('finalScore');
const tutorialBox = document.getElementById('tutorial');

// Game Constants
const GRAVITY = 0.4;
const FRICTION = 0.99; // Air resistance (slightly less friction)
const GROUND_FRICTION = 0.9; // Less friction on ground so it slides/bounces further (was 0.8)
const BOUNCE_DAMPENING = 0.75; // Bouncier (was 0.6)
const CANNON_BASE_X = 100;
const CANNON_BASE_Y_OFFSET = 100; // From bottom

// Game State
let gameState = 'AIMING'; // AIMING, CHARGING, FLYING, ENDED
let power = 0;
let maxPower = 35;
let angle = 0;
let distance = 0;
let highScore = 0;
let cameraOffset = 0;
let frameId;
let particles = [];

// Input State
let mouseX = 0;
let mouseY = 0;
let isMouseDown = false;

// Entities
let turkey = {
    x: 0, y: 0, vx: 0, vy: 0, r: 0, vr: 0, 
    radius: 20, 
    state: 'ALIVE', // ALIVE, ROASTED
    onGround: false
};

let obstacles = [];

/**
 * INITIALIZATION
 */
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

function init() {
    // Reset Turkey
    turkey.x = CANNON_BASE_X;
    turkey.y = canvas.height - CANNON_BASE_Y_OFFSET;
    turkey.vx = 0;
    turkey.vy = 0;
    turkey.r = 0;
    turkey.vr = 0;
    turkey.state = 'ALIVE';
    turkey.onGround = false;

    // Reset World
    cameraOffset = 0;
    power = 0;
    gameState = 'AIMING';
    obstacles = [];
    particles = [];
    generateObstacles(0, 2000); // Initial chunk

    // UI
    gameOverScreen.classList.add('hidden');
    tutorialBox.classList.remove('hidden');
    scoreDisplay.innerText = "0";
    
    // Start Loop if not running
    if (!frameId) loop();
}

/**
 * INPUT HANDLING
 */
function getPointerPos(e) {
    if (e.touches) {
        return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    }
    return { x: e.clientX, y: e.clientY };
}

function handleStart(e) {
    if (gameState === 'AIMING' || gameState === 'CHARGING') {
        isMouseDown = true;
        gameState = 'CHARGING';
        const pos = getPointerPos(e);
        mouseX = pos.x;
        mouseY = pos.y;
    }
}

function handleMove(e) {
    const pos = getPointerPos(e);
    mouseX = pos.x;
    mouseY = pos.y;
    
    if (gameState === 'AIMING' || gameState === 'CHARGING') {
        // Calculate angle based on mouse position relative to cannon
        const dy = (canvas.height - CANNON_BASE_Y_OFFSET) - mouseY;
        const dx = mouseX - CANNON_BASE_X;
        angle = Math.atan2(dy, dx);
        // Clamp angle
        if (angle < 0) angle = 0;
        if (angle > Math.PI / 2) angle = Math.PI / 2;
    }
}

function handleEnd(e) {
    if (gameState === 'CHARGING') {
        fireCannon();
    }
    isMouseDown = false;
}

window.addEventListener('mousedown', handleStart);
window.addEventListener('mousemove', handleMove);
window.addEventListener('mouseup', handleEnd);
window.addEventListener('touchstart', handleStart, {passive: false});
window.addEventListener('touchmove', handleMove, {passive: false});
window.addEventListener('touchend', handleEnd);

/**
 * GAME LOGIC
 */
function fireCannon() {
    gameState = 'FLYING';
    tutorialBox.classList.add('hidden');
    
    // Calculate velocity based on angle and power
    const velocity = power * 1.8; // Increased multiplier for more speed (was 1.5)
    turkey.vx = Math.cos(angle) * velocity;
    turkey.vy = -Math.sin(angle) * velocity;
    
    // Add some spin
    turkey.vr = (Math.random() - 0.5) * 0.5;

    // Boom effect
    createParticles(turkey.x, turkey.y, 20, '#555');
}

function generateObstacles(startX, endX) {
    // Generate items between startX and endX
    for (let x = startX; x < endX; x += Math.random() * 300 + 150) {
        if (x < 400) continue; // Don't spawn too close to cannon

        const typeRoll = Math.random();
        let type = 'PIE';
        
        if (typeRoll > 0.8) type = 'BOMB';
        else if (typeRoll > 0.5) type = 'TABLE';
        else type = 'PIE';

        obstacles.push({
            x: x,
            y: canvas.height - 50, // Ground level approximation
            type: type,
            hit: false,
            width: type === 'TABLE' ? 80 : 40,
            height: 40
        });
    }
}

function createParticles(x, y, count, color) {
    for (let i = 0; i < count; i++) {
        particles.push({
            x: x,
            y: y,
            vx: (Math.random() - 0.5) * 10,
            vy: (Math.random() - 0.5) * 10,
            life: 1.0,
            color: color
        });
    }
}

function createFeathers(x, y) {
    createParticles(x, y, 10, '#8B4513'); // Brown feathers
    createParticles(x, y, 5, '#FFF');    // White feathers
}

function update() {
    // 1. Charging Logic
    if (gameState === 'CHARGING') {
        power += 0.5;
        if (power > maxPower) power = 0; // Cycle power
    }

    // 2. Physics Logic
    if (gameState === 'FLYING') {
        // Gravity
        turkey.vy += GRAVITY;
        
        // Apply Velocities
        turkey.x += turkey.vx;
        turkey.y += turkey.vy;
        turkey.r += turkey.vr;

        // Air Resistance
        turkey.vx *= FRICTION;
        turkey.vy *= FRICTION;

        // Ground Collision
        const groundY = canvas.height - 50;
        if (turkey.y + turkey.radius > groundY) {
            turkey.y = groundY - turkey.radius;
            turkey.vy *= -BOUNCE_DAMPENING;
            turkey.vx *= GROUND_FRICTION;
            turkey.vr *= GROUND_FRICTION;
            
            // Stop if too slow
            if (Math.abs(turkey.vx) < 0.1 && Math.abs(turkey.vy) < 0.5) {
                endGame(false);
            }
        }

        // Object Collision
        obstacles.forEach(obj => {
            if (obj.hit) return;

            // Simple box collision
            if (turkey.x + turkey.radius > obj.x && 
                turkey.x - turkey.radius < obj.x + obj.width &&
                turkey.y + turkey.radius > obj.y - obj.height) {
                
                if (obj.type === 'PIE') {
                    // Trampoline effect
                    turkey.vy = -18; // Big bounce
                    turkey.vx += 2; // Speed boost
                    createParticles(turkey.x, turkey.y, 10, '#FFA500'); // Orange filling
                    obj.hit = true; // Use up the pie
                } 
                else if (obj.type === 'BOMB') {
                    // Explosion
                    turkey.vy = -25;
                    turkey.vx += 10;
                    createParticles(turkey.x, turkey.y, 30, '#FF0000');
                    obj.hit = true;
                } 
                else if (obj.type === 'TABLE') {
                    // Game Over trap
                    turkey.vx = 0;
                    turkey.vy = 0;
                    turkey.y = obj.y - obj.height - turkey.radius + 15; // Sit on plate
                    endGame(true);
                }
            }
        });

        // Generate more terrain as we fly
        const rightEdge = turkey.x + canvas.width;
        const lastObstacle = obstacles[obstacles.length - 1];
        if (lastObstacle && lastObstacle.x < rightEdge) {
            generateObstacles(lastObstacle.x, rightEdge + 2000);
        }

        // Camera Follow
        if (turkey.x > CANNON_BASE_X + canvas.width / 4) {
            cameraOffset = turkey.x - (CANNON_BASE_X + canvas.width / 4);
        }

        // Update Distance
        distance = Math.floor(turkey.x / 10);
        scoreDisplay.innerText = distance;
    }

    // 3. Particle System
    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += GRAVITY * 0.5;
        p.life -= 0.02;
        if (p.life <= 0) particles.splice(i, 1);
    }
}

function endGame(isRoasted) {
    gameState = 'ENDED';
    turkey.state = isRoasted ? 'ROASTED' : 'ALIVE';
    
    // Update High Score
    if (distance > highScore) {
        highScore = distance;
        highScoreDisplay.innerText = highScore;
    }

    finalScoreSpan.innerText = distance;
    setTimeout(() => {
        gameOverScreen.classList.remove('hidden');
    }, 500);
}

function resetGame() {
    init();
}

/**
 * RENDERING
 */
function draw() {
    // Clear
    ctx.fillStyle = '#87CEEB'; // Sky blue fallback
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw Background Gradient
    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    gradient.addColorStop(0, '#87CEEB'); // Sky
    gradient.addColorStop(1, '#FFF3E0'); // Horizon
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw Sun
    ctx.fillStyle = '#FFD700';
    ctx.beginPath();
    ctx.arc(canvas.width - 100, 100, 50, 0, Math.PI * 2);
    ctx.fill();

    ctx.save();
    
    // Apply Camera translation
    ctx.translate(-cameraOffset, 0);

    // Draw Ground
    ctx.fillStyle = '#558B2F'; // Grass green
    ctx.fillRect(cameraOffset, canvas.height - 50, canvas.width, 500); // Infinite appearing
    ctx.fillStyle = '#33691E'; // Top border
    ctx.fillRect(cameraOffset, canvas.height - 50, canvas.width, 10);

    // Draw Distance Markers (Every 100 ft)
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.font = '20px Arial';
    const startMarker = Math.floor(cameraOffset / 1000) * 1000;
    for(let m = startMarker; m < cameraOffset + canvas.width; m += 500) {
        if (m === 0) continue;
        ctx.fillText(`${Math.floor(m/10)}ft`, m, canvas.height - 60);
        ctx.fillRect(m, canvas.height - 50, 2, 20);
    }

    // Draw Obstacles
    obstacles.forEach(obj => {
        if (obj.hit && obj.type !== 'TABLE') return; // Don't draw consumed items

        const y = obj.y - obj.height;
        
        if (obj.type === 'PIE') {
            // Draw Pie
            ctx.font = '40px Arial';
            ctx.fillText('ü•ß', obj.x, obj.y);
        } else if (obj.type === 'BOMB') {
            // Draw Bomb
            ctx.font = '40px Arial';
            ctx.fillText('üí£', obj.x, obj.y);
        } else if (obj.type === 'TABLE') {
            // Draw Table
            ctx.font = '60px Arial';
            ctx.fillText('üçΩÔ∏è', obj.x - 10, obj.y + 10);
        }
    });

    // Draw Cannon (Only if near start)
    if (cameraOffset < 500) {
        ctx.save();
        ctx.translate(CANNON_BASE_X, canvas.height - CANNON_BASE_Y_OFFSET);
        
        // Draw Mount
        ctx.fillStyle = '#4a4a4a';
        ctx.beginPath();
        ctx.arc(0, 0, 30, 0, Math.PI * 2);
        ctx.fill();

        // Draw Barrel
        ctx.rotate(-angle);
        ctx.fillStyle = '#333';
        ctx.fillRect(0, -20, 100, 40);
        
        // Barrel Rings
        ctx.fillStyle = '#Gold';
        ctx.fillRect(90, -22, 10, 44);

        ctx.restore();

        // Draw Power Meter next to cannon
        if (gameState === 'CHARGING' || gameState === 'AIMING') {
            ctx.fillStyle = 'white';
            ctx.fillRect(CANNON_BASE_X - 50, canvas.height - CANNON_BASE_Y_OFFSET - 100, 10, 80);
            
            // Fill based on power
            const powerPercent = power / maxPower;
            const powerColor = powerPercent > 0.8 ? 'red' : (powerPercent > 0.5 ? 'orange' : 'green');
            ctx.fillStyle = powerColor;
            const h = 80 * powerPercent;
            ctx.fillRect(CANNON_BASE_X - 50, canvas.height - CANNON_BASE_Y_OFFSET - 20 - h, 10, h);
        }
    }

    // Draw Turkey
    ctx.save();
    ctx.translate(turkey.x, turkey.y);
    ctx.rotate(turkey.r);
    ctx.font = '40px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    if (turkey.state === 'ROASTED') {
        ctx.fillText('üçó', 0, 0);
    } else {
        // Switch sprite based on velocity to look like it's tumbling
        ctx.fillText('ü¶É', 0, 0);
    }
    ctx.restore();

    // Draw Particles
    particles.forEach(p => {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    });

    ctx.restore();
}

/**
 * MAIN LOOP
 */
function loop() {
    update();
    draw();
    frameId = requestAnimationFrame(loop);
}

// Start Game
init();

</script>
</body>
</html>
